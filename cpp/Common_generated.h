// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_COMMON_SPLAYAPI_H_
#define FLATBUFFERS_GENERATED_COMMON_SPLAYAPI_H_

#include "flatbuffers/flatbuffers.h"

namespace SplayApi {

struct GetFirmwareUpdateStatus;
struct GetFirmwareUpdateStatusBuilder;

struct SystemInfo;
struct SystemInfoBuilder;

enum UNIVERSE_TYPE {
  UNIVERSE_TYPE_DMX = 0,
  UNIVERSE_TYPE_ARTNET = 1,
  UNIVERSE_TYPE_SACN = 2,
  UNIVERSE_TYPE_NONE = 3,
  UNIVERSE_TYPE_MIN = UNIVERSE_TYPE_DMX,
  UNIVERSE_TYPE_MAX = UNIVERSE_TYPE_NONE
};

inline const UNIVERSE_TYPE (&EnumValuesUNIVERSE_TYPE())[4] {
  static const UNIVERSE_TYPE values[] = {
    UNIVERSE_TYPE_DMX,
    UNIVERSE_TYPE_ARTNET,
    UNIVERSE_TYPE_SACN,
    UNIVERSE_TYPE_NONE
  };
  return values;
}

inline const char * const *EnumNamesUNIVERSE_TYPE() {
  static const char * const names[5] = {
    "DMX",
    "ARTNET",
    "SACN",
    "NONE",
    nullptr
  };
  return names;
}

inline const char *EnumNameUNIVERSE_TYPE(UNIVERSE_TYPE e) {
  if (flatbuffers::IsOutRange(e, UNIVERSE_TYPE_DMX, UNIVERSE_TYPE_NONE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesUNIVERSE_TYPE()[index];
}

enum WEBSOCKET_OUTPUT {
  WEBSOCKET_OUTPUT_NOTHING = -2,
  WEBSOCKET_OUTPUT_ALL = -1,
  WEBSOCKET_OUTPUT_MIN = WEBSOCKET_OUTPUT_NOTHING,
  WEBSOCKET_OUTPUT_MAX = WEBSOCKET_OUTPUT_ALL
};

inline const WEBSOCKET_OUTPUT (&EnumValuesWEBSOCKET_OUTPUT())[2] {
  static const WEBSOCKET_OUTPUT values[] = {
    WEBSOCKET_OUTPUT_NOTHING,
    WEBSOCKET_OUTPUT_ALL
  };
  return values;
}

inline const char * const *EnumNamesWEBSOCKET_OUTPUT() {
  static const char * const names[3] = {
    "NOTHING",
    "ALL",
    nullptr
  };
  return names;
}

inline const char *EnumNameWEBSOCKET_OUTPUT(WEBSOCKET_OUTPUT e) {
  if (flatbuffers::IsOutRange(e, WEBSOCKET_OUTPUT_NOTHING, WEBSOCKET_OUTPUT_ALL)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(WEBSOCKET_OUTPUT_NOTHING);
  return EnumNamesWEBSOCKET_OUTPUT()[index];
}

/// Don't change order
enum PIXEL_ORDER {
  PIXEL_ORDER_RGB = 0,
  PIXEL_ORDER_RBG = 1,
  PIXEL_ORDER_GRB = 2,
  PIXEL_ORDER_GBR = 3,
  PIXEL_ORDER_BRG = 4,
  PIXEL_ORDER_BGR = 5,
  PIXEL_ORDER_RGBW = 6,
  PIXEL_ORDER_RBGW = 7,
  PIXEL_ORDER_GRBW = 8,
  PIXEL_ORDER_GBRW = 9,
  PIXEL_ORDER_BRGW = 10,
  PIXEL_ORDER_BGRW = 11,
  PIXEL_ORDER_WRGB = 12,
  PIXEL_ORDER_WRBG = 13,
  PIXEL_ORDER_WGRB = 14,
  PIXEL_ORDER_WGBR = 15,
  PIXEL_ORDER_WBRG = 16,
  PIXEL_ORDER_WBGR = 17,
  PIXEL_ORDER_RWGB = 18,
  PIXEL_ORDER_RWBG = 19,
  PIXEL_ORDER_GWRB = 20,
  PIXEL_ORDER_GWBR = 21,
  PIXEL_ORDER_BWRG = 22,
  PIXEL_ORDER_BWGR = 23,
  PIXEL_ORDER_RGWB = 24,
  PIXEL_ORDER_RBWG = 25,
  PIXEL_ORDER_GRWB = 26,
  PIXEL_ORDER_GBWR = 27,
  PIXEL_ORDER_BRWG = 28,
  PIXEL_ORDER_BGWR = 29,
  PIXEL_ORDER_W = 30,
  PIXEL_ORDER_RRGGBB = 31,
  PIXEL_ORDER_RRGGBBWW = 32,
  PIXEL_ORDER_MIN = PIXEL_ORDER_RGB,
  PIXEL_ORDER_MAX = PIXEL_ORDER_RRGGBBWW
};

inline const PIXEL_ORDER (&EnumValuesPIXEL_ORDER())[33] {
  static const PIXEL_ORDER values[] = {
    PIXEL_ORDER_RGB,
    PIXEL_ORDER_RBG,
    PIXEL_ORDER_GRB,
    PIXEL_ORDER_GBR,
    PIXEL_ORDER_BRG,
    PIXEL_ORDER_BGR,
    PIXEL_ORDER_RGBW,
    PIXEL_ORDER_RBGW,
    PIXEL_ORDER_GRBW,
    PIXEL_ORDER_GBRW,
    PIXEL_ORDER_BRGW,
    PIXEL_ORDER_BGRW,
    PIXEL_ORDER_WRGB,
    PIXEL_ORDER_WRBG,
    PIXEL_ORDER_WGRB,
    PIXEL_ORDER_WGBR,
    PIXEL_ORDER_WBRG,
    PIXEL_ORDER_WBGR,
    PIXEL_ORDER_RWGB,
    PIXEL_ORDER_RWBG,
    PIXEL_ORDER_GWRB,
    PIXEL_ORDER_GWBR,
    PIXEL_ORDER_BWRG,
    PIXEL_ORDER_BWGR,
    PIXEL_ORDER_RGWB,
    PIXEL_ORDER_RBWG,
    PIXEL_ORDER_GRWB,
    PIXEL_ORDER_GBWR,
    PIXEL_ORDER_BRWG,
    PIXEL_ORDER_BGWR,
    PIXEL_ORDER_W,
    PIXEL_ORDER_RRGGBB,
    PIXEL_ORDER_RRGGBBWW
  };
  return values;
}

inline const char * const *EnumNamesPIXEL_ORDER() {
  static const char * const names[34] = {
    "RGB",
    "RBG",
    "GRB",
    "GBR",
    "BRG",
    "BGR",
    "RGBW",
    "RBGW",
    "GRBW",
    "GBRW",
    "BRGW",
    "BGRW",
    "WRGB",
    "WRBG",
    "WGRB",
    "WGBR",
    "WBRG",
    "WBGR",
    "RWGB",
    "RWBG",
    "GWRB",
    "GWBR",
    "BWRG",
    "BWGR",
    "RGWB",
    "RBWG",
    "GRWB",
    "GBWR",
    "BRWG",
    "BGWR",
    "W",
    "RRGGBB",
    "RRGGBBWW",
    nullptr
  };
  return names;
}

inline const char *EnumNamePIXEL_ORDER(PIXEL_ORDER e) {
  if (flatbuffers::IsOutRange(e, PIXEL_ORDER_RGB, PIXEL_ORDER_RRGGBBWW)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPIXEL_ORDER()[index];
}

enum SETTING {
  SETTING_IS_SPARE = 0,
  SETTING_SYSTEM_NAME = 1,
  SETTING_PLAYBACK_CONFIG = 2,
  SETTING_PASSWORD = 3,
  SETTING_HELP_HINTS = 4,
  SETTING_SERIALNO = 5,
  SETTING_ENABLE_PASSWORD = 6,
  SETTING_SMTP = 7,
  SETTING_EMAIL = 8,
  SETTING_INPUT = 9,
  SETTING_OUTPUT = 10,
  SETTING_DMX = 11,
  SETTING_ARTNET = 12,
  SETTING_SACN = 13,
  SETTING_LOCATION = 14,
  SETTING_NTP = 15,
  SETTING_BASE_PATH = 16,
  SETTING_CUE_PATH = 17,
  SETTING_HOME_INTERFACE = 18,
  SETTING_UDP = 19,
  SETTING_TCP = 20,
  SETTING_RS232C = 21,
  SETTING_OSC = 22,
  SETTING_IEEE1588_CONFIG = 23,
  SETTING_IEEE1588_ACTIVE = 24,
  SETTING_LOCK_STATUS = 25,
  SETTING_DB_VERSION = 26,
  SETTING_MIN = SETTING_IS_SPARE,
  SETTING_MAX = SETTING_DB_VERSION
};

inline const SETTING (&EnumValuesSETTING())[27] {
  static const SETTING values[] = {
    SETTING_IS_SPARE,
    SETTING_SYSTEM_NAME,
    SETTING_PLAYBACK_CONFIG,
    SETTING_PASSWORD,
    SETTING_HELP_HINTS,
    SETTING_SERIALNO,
    SETTING_ENABLE_PASSWORD,
    SETTING_SMTP,
    SETTING_EMAIL,
    SETTING_INPUT,
    SETTING_OUTPUT,
    SETTING_DMX,
    SETTING_ARTNET,
    SETTING_SACN,
    SETTING_LOCATION,
    SETTING_NTP,
    SETTING_BASE_PATH,
    SETTING_CUE_PATH,
    SETTING_HOME_INTERFACE,
    SETTING_UDP,
    SETTING_TCP,
    SETTING_RS232C,
    SETTING_OSC,
    SETTING_IEEE1588_CONFIG,
    SETTING_IEEE1588_ACTIVE,
    SETTING_LOCK_STATUS,
    SETTING_DB_VERSION
  };
  return values;
}

inline const char * const *EnumNamesSETTING() {
  static const char * const names[28] = {
    "IS_SPARE",
    "SYSTEM_NAME",
    "PLAYBACK_CONFIG",
    "PASSWORD",
    "HELP_HINTS",
    "SERIALNO",
    "ENABLE_PASSWORD",
    "SMTP",
    "EMAIL",
    "INPUT",
    "OUTPUT",
    "DMX",
    "ARTNET",
    "SACN",
    "LOCATION",
    "NTP",
    "BASE_PATH",
    "CUE_PATH",
    "HOME_INTERFACE",
    "UDP",
    "TCP",
    "RS232C",
    "OSC",
    "IEEE1588_CONFIG",
    "IEEE1588_ACTIVE",
    "LOCK_STATUS",
    "DB_VERSION",
    nullptr
  };
  return names;
}

inline const char *EnumNameSETTING(SETTING e) {
  if (flatbuffers::IsOutRange(e, SETTING_IS_SPARE, SETTING_DB_VERSION)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSETTING()[index];
}

struct GetFirmwareUpdateStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GetFirmwareUpdateStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROGRESS = 4,
    VT_ERROR = 6
  };
  uint8_t progress() const {
    return GetField<uint8_t>(VT_PROGRESS, 0);
  }
  const flatbuffers::String *error() const {
    return GetPointer<const flatbuffers::String *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PROGRESS) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyString(error()) &&
           verifier.EndTable();
  }
};

struct GetFirmwareUpdateStatusBuilder {
  typedef GetFirmwareUpdateStatus Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_progress(uint8_t progress) {
    fbb_.AddElement<uint8_t>(GetFirmwareUpdateStatus::VT_PROGRESS, progress, 0);
  }
  void add_error(flatbuffers::Offset<flatbuffers::String> error) {
    fbb_.AddOffset(GetFirmwareUpdateStatus::VT_ERROR, error);
  }
  explicit GetFirmwareUpdateStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GetFirmwareUpdateStatusBuilder &operator=(const GetFirmwareUpdateStatusBuilder &);
  flatbuffers::Offset<GetFirmwareUpdateStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetFirmwareUpdateStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetFirmwareUpdateStatus> CreateGetFirmwareUpdateStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t progress = 0,
    flatbuffers::Offset<flatbuffers::String> error = 0) {
  GetFirmwareUpdateStatusBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_progress(progress);
  return builder_.Finish();
}

inline flatbuffers::Offset<GetFirmwareUpdateStatus> CreateGetFirmwareUpdateStatusDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t progress = 0,
    const char *error = nullptr) {
  auto error__ = error ? _fbb.CreateString(error) : 0;
  return SplayApi::CreateGetFirmwareUpdateStatus(
      _fbb,
      progress,
      error__);
}

struct SystemInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SystemInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CPU_USAGE = 4,
    VT_TEMPERATURE = 6,
    VT_TIME = 8
  };
  float cpu_usage() const {
    return GetField<float>(VT_CPU_USAGE, 0.0f);
  }
  float temperature() const {
    return GetField<float>(VT_TEMPERATURE, 0.0f);
  }
  const flatbuffers::String *time() const {
    return GetPointer<const flatbuffers::String *>(VT_TIME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_CPU_USAGE) &&
           VerifyField<float>(verifier, VT_TEMPERATURE) &&
           VerifyOffset(verifier, VT_TIME) &&
           verifier.VerifyString(time()) &&
           verifier.EndTable();
  }
};

struct SystemInfoBuilder {
  typedef SystemInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cpu_usage(float cpu_usage) {
    fbb_.AddElement<float>(SystemInfo::VT_CPU_USAGE, cpu_usage, 0.0f);
  }
  void add_temperature(float temperature) {
    fbb_.AddElement<float>(SystemInfo::VT_TEMPERATURE, temperature, 0.0f);
  }
  void add_time(flatbuffers::Offset<flatbuffers::String> time) {
    fbb_.AddOffset(SystemInfo::VT_TIME, time);
  }
  explicit SystemInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SystemInfoBuilder &operator=(const SystemInfoBuilder &);
  flatbuffers::Offset<SystemInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SystemInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<SystemInfo> CreateSystemInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    float cpu_usage = 0.0f,
    float temperature = 0.0f,
    flatbuffers::Offset<flatbuffers::String> time = 0) {
  SystemInfoBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_temperature(temperature);
  builder_.add_cpu_usage(cpu_usage);
  return builder_.Finish();
}

inline flatbuffers::Offset<SystemInfo> CreateSystemInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    float cpu_usage = 0.0f,
    float temperature = 0.0f,
    const char *time = nullptr) {
  auto time__ = time ? _fbb.CreateString(time) : 0;
  return SplayApi::CreateSystemInfo(
      _fbb,
      cpu_usage,
      temperature,
      time__);
}

}  // namespace SplayApi

#endif  // FLATBUFFERS_GENERATED_COMMON_SPLAYAPI_H_
